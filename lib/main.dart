import 'package:flutter/material.dart';
import 'package:timezone/data/latest.dart' as tz; // Timezone package
import 'package:logging/logging.dart';          // Logging package

import 'package:firebase_core/firebase_core.dart'; // Import Firebase Core
import 'package:firebase_messaging/firebase_messaging.dart'; // Import Firebase Messaging
// import 'package:flutter_local_notifications/flutter_local_notifications.dart'; // Not directly needed in main, but service uses it

// --- Project-Specific Imports ---
import 'src/app.dart';
import 'src/settings/settings_controller.dart';
import 'src/settings/settings_service.dart';
import 'src/golden_ticket/auth/auth_state.dart';
import 'src/golden_ticket/game_event_service.dart';
import 'push_notification_service.dart'; // Import the Push Notification Service
import 'package:firebase_crashlytics/firebase_crashlytics.dart';
import 'firebase_options.dart'; // Import Firebase Options (generated by FlutterFire CLI)
// Logger specifically for the main entry point of the application.
final _log = Logger('main');

// --- Logging Setup ---
// Keep your existing logging setup - it's good!
void formatLogfmt(LogRecord record) {
  final time = record.time;
  final level = record.level.name;
  final logger = record.loggerName.isNotEmpty ? ' logger=${record.loggerName}' : '';
  final msg = 'msg="${record.message}"';
  final error = record.error != null ? ' error="${record.error}"' : '';
  final stack = record.stackTrace != null ? '\n${record.stackTrace}' : '';
  final formattedLog = 'time="$time" level=$level$logger $msg$error$stack';
  // ignore: avoid_print
  print(formattedLog);
}

void setupLogging() {
  hierarchicalLoggingEnabled = true;
  Logger.root.level = Level.ALL;
  Logger.root.onRecord.listen((record) {
    formatLogfmt(record);
  });
}
// --- End Logging Setup ---

// --- Background Message Handler ---
// MUST BE a top-level function (not part of a class)
// Needs access to your logger and the PushNotificationService static methods
@pragma('vm:entry-point') // Avoid tree shaking
Future<void> _firebaseMessagingBackgroundHandler(RemoteMessage message) async {
  // Initialize Firebase FIRST (required for background isolate)
  // Use the options generated by FlutterFire CLI
  await Firebase.initializeApp(options: DefaultFirebaseOptions.currentPlatform);

  // Setup logging within the isolate if needed, or use a basic print/logThis
  // Note: Accessing the main isolate's logger directly isn't straightforward.
  // Using a simple print or your logThis function might be necessary here.
  // For simplicity, we'll assume logThis works or use print.
  print('Handling a background message: ${message.messageId}'); // Using print for simplicity in background isolate
  print('Background Message data: ${message.data}');
  if (message.notification != null) {
    print('Background Message also contained a notification: ${message.notification}');
  }

  // Setup flutter_local_notifications (channels etc.) within the isolate
  // This ensures it's ready before showing the notification
  await PushNotificationService.setupFlutterNotifications();
  print('Background isolate: Flutter notifications setup complete.');

  // Show the notification using the static method from PushNotificationService
  PushNotificationService.showFlutterNotification(message);
  print('Background isolate: Show notification called.');
}
// --- End Background Message Handler ---


// Keep your global instance if you prefer, though it's only initialized in main
final PushNotificationService _pushNotificationService = PushNotificationService();

/// The main entry point of the Flutter application.
void main() async {
  // Ensure Flutter bindings are initialized.
  WidgetsFlutterBinding.ensureInitialized();

  // Initialize the logging system first.
  setupLogging();
  _log.info('Application starting...');

  // --- Initialize Firebase and Push Service ---
  try {
    // Initialize Firebase Core (required for other Firebase services)
    // Use the options generated by FlutterFire CLI
    await Firebase.initializeApp(
      options: DefaultFirebaseOptions.currentPlatform, // Use generated options
    );
    _log.info("Firebase Core initialized successfully");
  FlutterError.onError = FirebaseCrashlytics.instance.recordFlutterFatalError;

    // --- Setup Notifications (AFTER Firebase Init, BEFORE runApp) ---

    // 1. Set the background messaging handler
    FirebaseMessaging.onBackgroundMessage(_firebaseMessagingBackgroundHandler);
    _log.info("Firebase background message handler registered.");

    // 2. Setup notification channels and initialize local notifications plugin
    // This needs to be done early for both foreground and background.
    await PushNotificationService.setupFlutterNotifications();
    _log.info("Flutter Local Notifications setup complete (channels etc.).");

    // 3. Initialize your Push Notification Service instance *after* Firebase Core init
    // This sets up foreground listeners, gets token etc.
    await _pushNotificationService.initialize();
    _log.info("Push Notification Service instance initialized (foreground listeners, token).");

    // --- End Notifications Setup ---

  } catch (e, stackTrace) { // Catch stack trace for better debugging
    _log.severe("Error during Firebase Core or Push Service initialization: $e", e, stackTrace);
    // Handle critical initialization errors if necessary
    // Consider showing an error message to the user or exiting.
  }
  // --- End Firebase and Push Service Init ---


  // Initialize the timezone database.
  tz.initializeTimeZones();
  _log.info('Timezone database initialized.');

  // Initialize the SettingsController.
  final settingsController = SettingsController(SettingsService());
  await settingsController.loadSettings();
  _log.info('Settings loaded.');

  // Initialize the AuthState controller.
  final authState = AuthState();
  await authState.init(); // Load persisted auth state
  _log.info('AuthState initialized. Signed In: ${authState.isSignedIn}');

  // Instantiate the GameEventService.
  // Note: GameEventService might need AuthState, ensure it's passed if required
  final gameEventService = GameEventService(authState);
  const String defaultGame = "lotto649";

  // --- Initial Data Fetch and Cache Population (Only if Signed In) ---
  // Keep your existing data fetching logic
  if (authState.isSignedIn) {
    _log.info("User is signed in. Fetching initial game info & checking results cache for '$defaultGame'...");
    String? nextDrawDate;
    String? lastDrawDate;
    try {
      // Step 1: Get the upcoming draw date.
      _log.fine("Fetching/Updating GameDrawInfo for $defaultGame via service...");
      nextDrawDate = await gameEventService.getNextDrawDate(defaultGame, forceRefresh: true);

      if (nextDrawDate != null) {
        _log.info("Successfully fetched/updated GameDrawInfo for $defaultGame. Next Draw: $nextDrawDate");
        // Step 2: Calculate the previous draw date.
        _log.fine("Calculating last draw date for $defaultGame using next draw: $nextDrawDate...");
        lastDrawDate = await gameEventService.calculateLastDrawDate(defaultGame, nextDrawDate);

        if (lastDrawDate != null) {
          _log.info("Calculated last draw date for $defaultGame: $lastDrawDate");
          // Step 3: Populate the local cache.
          _log.fine("Calling handleInitialCachePopulation for $defaultGame (Last: $lastDrawDate, Next: $nextDrawDate)...");
          await gameEventService.handleInitialCachePopulation(defaultGame, lastDrawDate, nextDrawDate);
          _log.info("Initial cache population check complete for $defaultGame.");
        } else {
          _log.severe("Failed to calculate last draw date for $defaultGame.");
        }
      } else {
        _log.severe("Failed to get next draw date for $defaultGame from service.");
      }
    } catch (e, stackTrace) { // Catch stack trace
      _log.severe("Error during initial game info fetch or cache population on startup: $e", e, stackTrace);
    }
  } else {
    _log.info("User is not signed in. Skipping initial game info fetch and cache population.");
  }

  // Run the main application UI.
  // Pass the controllers/services needed by MyApp
  runApp(
    MyApp(
      settingsController: settingsController, // Pass settings controller
      authState: authState, // Pass the single, initialized instance.
      // You might need to pass gameEventService or pushNotificationService too,
      // depending on how MyApp and its children access them (e.g., Provider, GetIt).
    ),
  );
  _log.info('Application running.');
} // End of main